#SWEA_5105_미로의거리
## 01_Code
from collections import deque

# 상하좌우
move_d = [ [-1,0], [1,0], [0,-1], [0,1] ] 

T = int(input())
for tc in range(1, T+1) :
    N = int(input())
    # maze_arr = [list(map(int, input())) for _ in range(N)]
    maze_arr = []

    s_r, s_c = -1, -1
    flag_s_rc = 0
    for r in range(N):
        temp_li = list(map(int, input()))

        if flag_s_rc == 0 :
            for c in range(N) :
                if temp_li[c] == 2:
                    s_r, s_c = r, c
                    flag_s_rc = 1
                    break

        maze_arr.append(temp_li)

    # 최단경로이기 때문에
    ## BFS 사용
    ## BFS는 Queue를 사용하면 편하기 때문에 queue 사용
    # 특히, deque을 사용
    q = deque()
    # list를 전송보단 tuple 전송이 빠름
    ## tuple을 사용하는 이유는 원소값을 변경하지 않을 것이기 때문
    q.append((s_r,s_c))
    visited= [[0]*N for _ in range(N)]
    visited[s_r][s_c] = 1

    flag = False

    answer = -1

    while q :
        
        answer += 1

        for _ in range(len(q)) :
            r, c = q.popleft()

            for dr, dc in move_d :
                nr = r + dr
                nc = c + dc
                # 아래의 조건을 만족하면 가라
                # 1. map 안쪽이어야한다.
                # 2. 1이 아니면 이동 가능
                # 3. 방문 안했어야 한다.

                # 위 조건 중 하나라도 만족하지 않으면 가지 마라
                # 1. map 바깥쪽이면 건너뛴다
                # 2. 1이 이면 건너뛴다
                # 3. 방문 했었으면 건너뛴다

                if 0>nr or nr>=N or 0>nc or nc>=N : continue
                if maze_arr[nr][nc] or visited[nr][nc] : continue

                if maze_arr[nr][nc] == 3 :
                    flag = True
                    break

                visited[nr][nc] = 1
                q.append((nr, nc))
            if flag :
                break
        if flag :
                break
        
    if not flag :
        answer = 0
        
    print(f"#{tc} {answer}")